#include <array>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>

using namespace std;

struct Point {
	int col;
	int row;
	int height;
};

class Heightmap {
	array<array<int, 100>, 100> heightmap;
	int map_width;
	int map_height;
	vector<Point> low_points;
	vector<int> basins;

	void parse(vector<string> &input) {
		int row = 0;
		for (auto &str: input) {
			map_width = str.length();
			for (size_t i = 0; i < str.length(); i++) {
				char c = str[i];
				int height = c - '0';
				this->heightmap[row][i] = height;
			}
			row++;
		}
		map_height = row;
		cout << "Map dimensions: " << to_string(map_width) << "x" << to_string(map_height) << endl;
	}

	bool isLowPoint(int col, int row) {
		int top_left = ((row > 0) && (col > 0)) ? this->heightmap[row - 1][col - 1] : 10;
		int top = (row > 0) ? this->heightmap[row - 1][col] : 10;
		int top_right = ((row > 0) && ((col + 1) < this->map_width)) ? this->heightmap[row - 1][col + 1] : 10;
		int left = (col > 0) ? this->heightmap[row][col - 1] : 10;
		int center = this->heightmap[row][col];
		int right = ((col + 1) < this->map_width) ? this->heightmap[row][col + 1] : 10;
		int bottom_left = (((row + 1) < this->map_height) && (col > 0)) ? this->heightmap[row + 1][col - 1] : 10;
		int bottom = ((row + 1) < this->map_height) ? this->heightmap[row + 1][col] : 10;
		int bottom_right = (((row + 1) < this->map_height) && ((col + 1) < this->map_width)) ? this->heightmap[row + 1][col + 1] : 10;

		bool isLowest = ((center < top_left) &&
							(center < top) &&
							(center < top_right) &&
							(center < left) &&
							(center < right) &&
							(center < bottom_left) &&
							(center < bottom) &&
							(center < bottom_right));

		return isLowest;
	}

	void findLowPoints() {
		for (size_t row = 0; row < this->map_height; row++) {
			for (size_t col = 0; col < this->map_width; col++) {
				if (isLowPoint(col, row)) {
					Point p;
					p.col = col;
					p.row = row;
					p.height = this->heightmap[row][col];
					low_points.push_back(p);
				}
			}
		}
	}

	vector<Point> findNeighbours(Point &p) {
		vector<Point> neighbours;
		int col = p.col;
		int row = p.row;
		int height = p.height + 1;

		if (height < 9) {
			// Top-left
			if ((row > 0) && (col > 0) && (this->heightmap[row - 1][col - 1] == height)) {
				Point pp;
				pp.col = col - 1;
				pp.row = row - 1;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Top
			if ((row > 0) && (this->heightmap[row - 1][col] == height)) {
				Point pp;
				pp.col = col;
				pp.row = row - 1;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Top-right
			if ((row > 0) && ((col + 1) < this->map_width) && (this->heightmap[row - 1][col + 1] == height)) {
				Point pp;
				pp.col = col + 1;
				pp.row = row - 1;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Left
			if ((col > 0) && (this->heightmap[row][col - 1] == height)) {
				Point pp;
				pp.col = col - 1;
				pp.row = row;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Right
			if (((col + 1) < this->map_width) && (this->heightmap[row][col + 1] == height)) {
				Point pp;
				pp.col = col + 1;
				pp.row = row;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Bottom-left
			if (((row + 1) < this->map_height) && (col > 0) && (this->heightmap[row + 1][col - 1] == height)) {
				Point pp;
				pp.col = col - 1;
				pp.row = row + 1;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Bottom
			if (((row + 1) < this->map_height) && (this->heightmap[row + 1][col] == height)) {
				Point pp;
				pp.col = col;
				pp.row = row + 1;
				pp.height = height;
				neighbours.push_back(pp);
			}

			// Bottom-right
			if (((row + 1) < this->map_height) && ((col + 1) < this->map_width) && (this->heightmap[row + 1][col + 1] == height)) {
				Point pp;
				pp.col = col + 1;
				pp.row = row + 1;
				pp.height = height;
				neighbours.push_back(pp);
			}
		}

		return neighbours;
	}

	vector<Point> findNeighbours(vector<Point> &neighbours) {
		vector<Point> new_neighbours;

		// TODO

		return new_neighbours;
	}

	void findBasins() {
		int size = 1; // low point is also part of basin
		for (auto &p: this->low_points) {
			cout << "Find neighbours for point " << to_string(p.col) << ',' << to_string(p.row) << endl;
			vector<Point> neighbours = findNeighbours(p);
			cout << "Found " << to_string(neighbours.size()) << " neighbours" << endl;
			while (!neighbours.empty()) {
				size += neighbours.size();
				neighbours = findNeighbours(neighbours);
				cout << "Found " << to_string(neighbours.size()) << " neighbours" << endl;
			}
		}
		this->basins.push_back(size);
		cout << "Basis with size " << to_string(size) << endl;
	}

	public:
	Heightmap(vector<string> &input) {
		parse(input);
		findLowPoints();
		findBasins();
	}

	int getAnswer() {
		int sum = 0;
		// TODO - sort basins
		// TODO - add together three largest basins
		return sum;
	}
};

int main(int argc, char *argv[]) {
	// First command line argument is the file to open
	if (argc != 2) {
		cout << "Usage: day9b <input.txt>" << endl;
		return -1;
	}

	// Open file
	string path = argv[1];
	ifstream file(path);

	// Read file
	string str;
	vector<string> input;
	while (getline(file, str)) {
		input.push_back(str);
	}

	// And go!
	Heightmap hm(input);
	int answer = hm.getAnswer();
	cout << "Answer: " << to_string(answer) << endl;

	return 0;
}
